#!/bin/bash
#
# WebOps PostgreSQL Addon
# Installs and configures PostgreSQL database (standalone or HA)
#
# This addon supports:
# - Standalone PostgreSQL installation
# - WAL archiving for backups
# - Performance tuning
# - Security hardening
#

set -euo pipefail

# Addon metadata
# Addon metadata (use local variables to avoid conflicts when sourced)
local ADDON_NAME="postgresql"
local ADDON_VERSION="14.0.0"
local ADDON_DESCRIPTION="PostgreSQL Database Server"

# Source libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../lib/common.sh"
source "${SCRIPT_DIR}/../lib/os.sh"
source "${SCRIPT_DIR}/../lib/state.sh"

# Configuration
# Configuration (use local variables to avoid conflicts when sourced)
local POSTGRES_VERSION="${POSTGRES_VERSION:-14}"
local POSTGRES_DATA_DIR="${POSTGRES_DATA_DIR:-/var/lib/postgresql/${POSTGRES_VERSION}/main}"
local POSTGRES_CONFIG_DIR="${POSTGRES_CONFIG_DIR:-/etc/postgresql/${POSTGRES_VERSION}/main}"
local POSTGRES_LOG_DIR="${POSTGRES_LOG_DIR:-/var/log/postgresql}"
local POSTGRES_RUN_DIR="${POSTGRES_RUN_DIR:-/var/run/postgresql}"

# Load configuration
load_config

#=============================================================================
# PostgreSQL Installation
#=============================================================================

install_postgresql_packages() {
    log_step "Installing PostgreSQL packages..."
    
    case "$OS_ID" in
        ubuntu|debian)
            # Add PostgreSQL APT repository
            if ! grep -q "apt.postgresql.org" /etc/apt/sources.list.d/* 2>/dev/null; then
                log_info "Adding PostgreSQL APT repository..."
                
                # Import repository key
                curl -fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor -o /usr/share/keyrings/postgresql-archive-keyring.gpg
                
                # Add repository
                echo "deb [signed-by=/usr/share/keyrings/postgresql-archive-keyring.gpg] http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list
                
                pkg_update
            fi
            
            # Install PostgreSQL packages
            pkg_install postgresql-"$POSTGRES_VERSION" \
                       postgresql-contrib-"$POSTGRES_VERSION" \
                       postgresql-server-dev-"$POSTGRES_VERSION" \
                       libpq-dev
            ;;
        rocky|almalinux)
            # Install PostgreSQL from AppStream
            pkg_install postgresql-server postgresql-contrib
            
            # Initialize database if not already done
            if [[ ! -d "$POSTGRES_DATA_DIR" ]]; then
                postgresql-setup --initdb --unit postgresql
            fi
            ;;
    esac
    
    log_success "PostgreSQL packages installed ✓"
}

configure_postgresql() {
    log_step "Configuring PostgreSQL..."
    
    # Create PostgreSQL user if it doesn't exist
    if ! id postgres &>/dev/null; then
        useradd -r -s /bin/bash postgres
    fi
    
    # Ensure directories exist with proper permissions
    ensure_directory "$POSTGRES_DATA_DIR" "postgres:postgres" "700"
    ensure_directory "$POSTGRES_LOG_DIR" "postgres:postgres" "755"
    ensure_directory "$POSTGRES_RUN_DIR" "postgres:postgres" "755"
    
    # Configure PostgreSQL for production use
    local postgresql_conf="$POSTGRES_CONFIG_DIR/postgresql.conf"
    local pg_hba_conf="$POSTGRES_CONFIG_DIR/pg_hba.conf"
    
    # Backup original configuration
    if [[ ! -f "$postgresql_conf.webops-backup" ]]; then
        cp "$postgresql_conf" "$postgresql_conf.webops-backup"
    fi
    
    # Create optimized PostgreSQL configuration
    cat > "$postgresql_conf" <<EOF
# WebOps PostgreSQL Configuration
# Generated by WebOps addons/postgresql.sh

# Connection Settings
listen_addresses = 'localhost'
port = 5432
max_connections = 200
superuser_reserved_connections = 3

# Memory Settings (adjust based on system RAM)
shared_buffers = 256MB
effective_cache_size = 1GB
work_mem = 4MB
maintenance_work_mem = 64MB

# WAL Settings for backup and replication
wal_level = replica
max_wal_size = 1GB
min_wal_size = 80MB
checkpoint_completion_target = 0.9
archive_mode = on
archive_command = 'cp %p /var/lib/postgresql/wal_archive/%f'
archive_timeout = 300

# Performance Settings
random_page_cost = 1.1
effective_io_concurrency = 200
default_statistics_target = 100

# Logging Settings
logging_collector = on
log_directory = '$POSTGRES_LOG_DIR'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_rotation_age = 1d
log_rotation_size = 100MB
log_min_duration_statement = 1000
log_checkpoints = on
log_connections = on
log_disconnections = on
log_lock_waits = on

# Security Settings
ssl = off
password_encryption = scram-sha-256
EOF
    
    # Configure pg_hba.conf for secure access
    if [[ ! -f "$pg_hba_conf.webops-backup" ]]; then
        cp "$pg_hba_conf" "$pg_hba_conf.webops-backup"
    fi
    
    cat > "$pg_hba_conf" <<EOF
# WebOps PostgreSQL Host-Based Authentication
# Generated by WebOps addons/postgresql.sh

# TYPE  DATABASE        USER            ADDRESS                 METHOD

# "local" is for Unix domain socket connections only
local   all             postgres                                peer
local   all             all                                     md5

# IPv4 local connections:
host    all             all             127.0.0.1/32            md5

# IPv6 local connections:
host    all             all             ::1/128                 md5

# Allow replication connections from localhost
host    replication     replicator      127.0.0.1/32            md5
host    replication     replicator      ::1/128                 md5
EOF
    
    # Create WAL archive directory
    ensure_directory "/var/lib/postgresql/wal_archive" "postgres:postgres" "700"
    
    log_success "PostgreSQL configured ✓"
}

setup_postgresql_service() {
    log_step "Setting up PostgreSQL service..."
    
    # Enable and start PostgreSQL service
    case "$OS_ID" in
        ubuntu|debian)
            service_enable postgresql
            service_restart postgresql
            ;;
        rocky|almalinux)
            service_enable postgresql
            service_restart postgresql
            ;;
    esac
    
    # Wait for PostgreSQL to start
    local max_attempts=10
    local attempt=1
    
    while (( attempt <= max_attempts )); do
        if pg_isready -q -h localhost -p 5432; then
            log_success "PostgreSQL service is running ✓"
            return 0
        fi
        
        log_info "Waiting for PostgreSQL to start (attempt $attempt/$max_attempts)..."
        sleep 2
        ((attempt++))
    done
    
    log_error "PostgreSQL failed to start"
    return 1
}

create_webops_database() {
    log_step "Creating WebOps database and user..."
    
    # Create webops user if it doesn't exist
    if ! sudo -u postgres psql -tAc "SELECT 1 FROM pg_roles WHERE rolname='webops'" | grep -q 1; then
        log_info "Creating PostgreSQL user: webops"
        
        # Generate or load password
        local pg_password_file="${WEBOPS_SECRETS}/postgres_webops.secret"
        if [[ -f "$pg_password_file" ]]; then
            local pg_password=$(cat "$pg_password_file")
        else
            local pg_password=$(openssl rand -base64 32)
            echo "$pg_password" > "$pg_password_file"
            chmod 600 "$pg_password_file"
            chown postgres:postgres "$pg_password_file"
        fi
        
        sudo -u postgres psql -c "CREATE USER webops WITH PASSWORD '$pg_password';"
        sudo -u postgres psql -c "ALTER USER webops CREATEDB;"
        
        log_info "PostgreSQL user 'webops' created"
    else
        log_info "PostgreSQL user 'webops' already exists"
    fi
    
    # Create webops_control_panel database if it doesn't exist
    if ! sudo -u postgres psql -lqt | cut -d \| -f 1 | grep -qw webops_control_panel; then
        log_info "Creating database: webops_control_panel"
        sudo -u postgres psql -c "CREATE DATABASE webops_control_panel OWNER webops;"
        
        # Grant necessary privileges
        sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE webops_control_panel TO webops;"
        
        log_info "Database 'webops_control_panel' created"
    else
        log_info "Database 'webops_control_panel' already exists"
    fi
    
    log_success "WebOps database setup completed ✓"
}

configure_postgresql_backups() {
    log_step "Configuring PostgreSQL backups..."
    
    # Create backup directory
    local backup_dir="${WEBOPS_ROOT:-/webops}/backups/postgresql"
    ensure_directory "$backup_dir" "postgres:postgres" "700"
    
    # Create backup script
    local backup_script="/usr/local/bin/webops-postgres-backup"
    cat > "$backup_script" <<'EOF'
#!/bin/bash
#
# WebOps PostgreSQL Backup Script
# Runs daily backups of PostgreSQL databases
#

set -euo pipefail

# Configuration
BACKUP_DIR="${WEBOPS_ROOT:-/webops}/backups/postgresql"
RETENTION_DAYS=7
POSTGRES_VERSION="${POSTGRES_VERSION:-14}"

# Create backup filename with timestamp
BACKUP_FILE="$BACKUP_DIR/postgres-backup-$(date +%Y%m%d-%H%M%S).sql"

# Create backup
sudo -u postgres pg_dumpall > "$BACKUP_FILE"

# Compress backup
gzip "$BACKUP_FILE"

# Remove old backups
find "$BACKUP_DIR" -name "postgres-backup-*.sql.gz" -mtime +$RETENTION_DAYS -delete

# Log backup completion
logger -t webops-postgres-backup "PostgreSQL backup completed: $(basename "$BACKUP_FILE.gz")"
EOF
    
    chmod +x "$backup_script"
    
    # Create cron job for daily backups at 2 AM
    local cron_job="0 2 * * * $backup_script"
    
    # Add to postgres user's crontab
    if ! sudo -u postgres crontab -l 2>/dev/null | grep -q "webops-postgres-backup"; then
        (sudo -u postgres crontab -l 2>/dev/null; echo "$cron_job") | sudo -u postgres crontab -
        log_info "Added daily backup cron job"
    else
        log_info "Backup cron job already exists"
    fi
    
    log_success "PostgreSQL backup configuration completed ✓"
}

optimize_postgresql_performance() {
    log_step "Optimizing PostgreSQL performance..."
    
    # Get system memory for tuning
    local total_memory_mb=$(get_total_memory)
    local shared_buffers_mb=$((total_memory_mb / 4))
    local effective_cache_size_mb=$((total_memory_mb * 3 / 4))
    
    # Update memory settings based on available RAM
    sed -i "s/shared_buffers = .*/shared_buffers = ${shared_buffers_mb}MB/" "$POSTGRES_CONFIG_DIR/postgresql.conf"
    sed -i "s/effective_cache_size = .*/effective_cache_size = ${effective_cache_size_mb}MB/" "$POSTGRES_CONFIG_DIR/postgresql.conf"
    
    # Adjust work_mem based on connections and memory
    local work_mem_mb=$((shared_buffers_mb / 200))
    sed -i "s/work_mem = .*/work_mem = ${work_mem_mb}MB/" "$POSTGRES_CONFIG_DIR/postgresql.conf"
    
    # Reload PostgreSQL configuration
    service_reload postgresql
    
    log_success "PostgreSQL performance optimized ✓"
}

#=============================================================================
# Health Checks
#=============================================================================

check_postgresql_health() {
    log_step "Checking PostgreSQL health..."
    
    # Check if PostgreSQL is running
    if ! pg_isready -q -h localhost -p 5432; then
        log_error "PostgreSQL is not running"
        return 1
    fi
    
    # Check database connectivity
    if ! sudo -u postgres psql -c "SELECT 1;" &>/dev/null; then
        log_error "PostgreSQL database connectivity check failed"
        return 1
    fi
    
    # Check disk space for data directory
    local data_usage=$(df "$POSTGRES_DATA_DIR" | awk 'NR==2{print $5}' | sed 's/%//')
    if [[ $data_usage -gt 80 ]]; then
        log_warn "PostgreSQL data directory is ${data_usage}% full"
    fi
    
    # Check number of connections
    local connections=$(sudo -u postgres psql -tAc "SELECT count(*) FROM pg_stat_activity;")
    local max_connections=$(sudo -u postgres psql -tAc "SHOW max_connections;" | head -1)
    
    if [[ $connections -gt $((max_connections * 80 / 100)) ]]; then
        log_warn "PostgreSQL connections: $connections/$max_connections (high usage)"
    fi
    
    log_success "PostgreSQL health check passed ✓"
    return 0
}

#=============================================================================
# Addon Lifecycle Management
#=============================================================================

addon_install() {
    log_info "Installing PostgreSQL addon..."
    
    # Install packages
    install_postgresql_packages
    
    # Configure PostgreSQL
    configure_postgresql
    
    # Setup service
    setup_postgresql_service
    
    # Create database and user
    create_webops_database
    
    # Configure backups
    configure_postgresql_backups
    
    # Optimize performance
    optimize_postgresql_performance
    
    # Run health check
    check_postgresql_health
    
    # Open firewall port for local access only
    firewall_open_port 5432 tcp
    
    # Mark as installed
    mark_component_installed "$ADDON_NAME" "$ADDON_VERSION"
    
    log_success "PostgreSQL addon installed successfully ✓"
}

addon_uninstall() {
    local purge="${1:-false}"
    
    log_info "Uninstalling PostgreSQL addon..."
    
    # Stop PostgreSQL service
    service_stop postgresql || true
    service_disable postgresql || true
    
    if [[ "$purge" == "true" ]]; then
        log_warn "Purging PostgreSQL data..."
        
        # Remove PostgreSQL packages
        case "$OS_ID" in
            ubuntu|debian)
                pkg_remove postgresql-"$POSTGRES_VERSION" \
                           postgresql-contrib-"$POSTGRES_VERSION" \
                           postgresql-server-dev-"$POSTGRES_VERSION" \
                           libpq-dev || true
                ;;
            rocky|almalinux)
                pkg_remove postgresql-server postgresql-contrib || true
                ;;
        esac
        
        # Remove data directory
        rm -rf "$POSTGRES_DATA_DIR" || true
        rm -rf /var/lib/postgresql/wal_archive || true
        
        # Remove configuration
        rm -f "$POSTGRES_CONFIG_DIR/postgresql.conf" "$POSTGRES_CONFIG_DIR/pg_hba.conf" || true
        
        # Restore backups if they exist
        if [[ -f "$postgresql_conf.webops-backup" ]]; then
            mv "$postgresql_conf.webops-backup" "$postgresql_conf"
        fi
        
        if [[ -f "$pg_hba_conf.webops-backup" ]]; then
            mv "$pg_hba_conf.webops-backup" "$pg_hba_conf"
        fi
        
        # Remove backup script and cron job
        rm -f /usr/local/bin/webops-postgres-backup
        sudo -u postgres crontab -l 2>/dev/null | grep -v "webops-postgres-backup" | sudo -u postgres crontab - || true
    fi
    
    # Close firewall port
    firewall_close_port 5432 tcp
    
    # Mark as removed
    mark_component_removed "$ADDON_NAME"
    
    log_success "PostgreSQL addon uninstalled ✓"
}

addon_status() {
    if is_component_installed "$ADDON_NAME"; then
        echo "PostgreSQL addon is installed (version: $(get_component_version "$ADDON_NAME"))"
        
        if check_postgresql_health >/dev/null 2>&1; then
            echo "Status: Running and healthy"
        else
            echo "Status: Running but health check failed"
        fi
        
        return 0
    else
        echo "PostgreSQL addon is not installed"
        return 1
    fi
}

addon_version() {
    echo "$ADDON_VERSION"
}

addon_metadata() {
    cat <<EOF
{
    "name": "$ADDON_NAME",
    "version": "$ADDON_VERSION",
    "description": "$ADDON_DESCRIPTION",
    "depends": ["base", "firewall"],
    "provides": ["database", "postgresql"],
    "ports": [5432],
    "services": ["postgresql"],
    "config_files": ["$POSTGRES_CONFIG_DIR/postgresql.conf", "$POSTGRES_CONFIG_DIR/pg_hba.conf"],
    "data_directories": ["$POSTGRES_DATA_DIR", "/var/lib/postgresql/wal_archive"],
    "log_directories": ["$POSTGRES_LOG_DIR"]
}
EOF
}

addon_sla() {
    cat <<EOF
{
    "availability_target": 99.9,
    "performance_targets": {
        "response_time": 100,
        "cpu_usage": 80.0,
        "memory_usage": 85.0,
        "disk_io": 90.0,
        "network_throughput": 1000.0
    },
    "recovery_objectives": {
        "rto": 300,
        "rpo": 900,
        "backup_frequency": 86400,
        "test_frequency": 604800
    },
    "support_level": "critical",
    "monitoring_requirements": {
        "health_check_interval": 60,
        "metrics_retention": 2592000,
        "alert_thresholds": {
            "connection_count": 180,
            "disk_usage": 85,
            "replication_lag": 60
        }
    }
}
EOF
}

addon_security() {
    cat <<EOF
{
    "privilege_level": "service",
    "data_access": ["database_data", "configuration"],
    "network_access": ["localhost", "127.0.0.1", "::1"],
    "authentication": {
        "method": "password",
        "encryption": "scram-sha-256",
        "certificate_validation": false
    },
    "authorization": {
        "role_based_access": true,
        "least_privilege": true,
        "privilege_separation": true
    },
    "encryption": {
        "data_at_rest": false,
        "data_in_transit": false,
        "backup_encryption": false
    },
    "audit": {
        "connection_logging": true,
        "query_logging": false,
        "configuration_changes": true,
        "access_failures": true
    },
    "vulnerability_management": {
        "security_updates": true,
        "vulnerability_scanning": false,
        "penetration_testing": false
    },
    "compliance": {
        "data_classification": "confidential",
        "retention_policy": true,
        "gdpr_compliance": false
    }
}
EOF
}

addon_health_check() {
    check_postgresql_health
}

addon_start() {
    log_step "Starting PostgreSQL service..."
    service_start postgresql
    sleep 5
    check_postgresql_health
}

addon_stop() {
    log_step "Stopping PostgreSQL service..."
    service_stop postgresql
}

addon_restart() {
    log_step "Restarting PostgreSQL service..."
    service_restart postgresql
    sleep 5
    check_postgresql_health
}

addon_configure() {
    configure_postgresql
    optimize_postgresql_performance
}

addon_validate() {
    log_step "Validating PostgreSQL configuration..."
    
    # Check configuration files
    if [[ ! -f "$POSTGRES_CONFIG_DIR/postgresql.conf" ]]; then
        log_error "PostgreSQL configuration file not found"
        return 1
    fi
    
    if [[ ! -f "$POSTGRES_CONFIG_DIR/pg_hba.conf" ]]; then
        log_error "PostgreSQL HBA configuration file not found"
        return 1
    fi
    
    # Check data directory
    if [[ ! -d "$POSTGRES_DATA_DIR" ]]; then
        log_error "PostgreSQL data directory not found"
        return 1
    fi
    
    # Validate configuration syntax
    if ! sudo -u postgres pg_ctl status -D "$POSTGRES_DATA_DIR" >/dev/null 2>&1; then
        log_warn "PostgreSQL is not running, but configuration appears valid"
    fi
    
    log_success "PostgreSQL configuration validation passed ✓"
    return 0
}

addon_backup() {
    log_step "Creating PostgreSQL backup..."
    
    local backup_dir="${WEBOPS_ROOT:-/webops}/backups/postgresql"
    local backup_file="$backup_dir/postgres-backup-$(date +%Y%m%d-%H%M%S).sql"
    
    ensure_directory "$backup_dir" "postgres:postgres" "700"
    
    # Create backup
    if sudo -u postgres pg_dumpall > "$backup_file"; then
        gzip "$backup_file"
        log_success "PostgreSQL backup created: ${backup_file}.gz"
        return 0
    else
        log_error "PostgreSQL backup failed"
        rm -f "$backup_file"
        return 1
    fi
}

addon_restore() {
    local backup_file="$1"
    
    if [[ -z "$backup_file" ]]; then
        log_error "Backup file not specified"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        log_error "Backup file not found: $backup_file"
        return 1
    fi
    
    log_step "Restoring PostgreSQL from backup: $backup_file"
    
    # Stop PostgreSQL
    service_stop postgresql
    
    # Extract backup if compressed
    local restore_file="$backup_file"
    if [[ "$backup_file" == *.gz ]]; then
        restore_file="/tmp/postgres-restore-$(date +%s).sql"
        gunzip -c "$backup_file" > "$restore_file"
    fi
    
    # Restore backup
    if sudo -u postgres psql < "$restore_file"; then
        log_success "PostgreSQL restore completed"
        
        # Clean up temporary file
        if [[ "$restore_file" != "$backup_file" ]]; then
            rm -f "$restore_file"
        fi
        
        # Start PostgreSQL
        service_start postgresql
        return 0
    else
        log_error "PostgreSQL restore failed"
        
        # Clean up temporary file
        if [[ "$restore_file" != "$backup_file" ]]; then
            rm -f "$restore_file"
        fi
        
        return 1
    fi
}

#=============================================================================
# Script Execution
#=============================================================================

# Handle command line arguments
action="${1:-install}"

# Only execute main logic if script is called directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    case "$action" in
    install)
        addon_install
        ;;
    uninstall)
        addon_uninstall "${2:-false}"
        ;;
    status)
        addon_status
        ;;
    version)
        addon_version
        ;;
    health)
        check_postgresql_health
        ;;
    *)
        log_error "Unknown action: $action"
        echo "Usage: $0 {install|uninstall [--purge]|status|version|health}"
        exit 1
        ;;
esac
fi
