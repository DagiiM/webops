from django.core.management.base import BaseCommand
from django.conf import settings
from pathlib import Path
import os
import shutil
# template_utils doesn't exist, so we'll define the function directly

class Command(BaseCommand):
    help = 'Initialize the unified template system for WebOps'

    def add_arguments(self, parser):
        parser.add_argument(
            '--force',
            action='store_true',
            help='Force re-initialization even if templates already exist',
        )
        parser.add_argument(
            '--backup-dir',
            type=str,
            default=None,
            help='Custom backup directory path',
        )

    def handle(self, *args, **options):
        force_reinit = options['force']
        backup_dir = options['backup_dir']
        
        self.stdout.write(
            self.style.SUCCESS('Starting WebOps template unification system initialization...')
        )
        
        # Initialize the unified template system
        try:
            result = initialize_templates(force_reinit=force_reinit, backup_dir=backup_dir)
            
            if result['success']:
                self.stdout.write(
                    self.style.SUCCESS(f"Template system initialized successfully!")
                )
                self.stdout.write(
                    self.style.SUCCESS(f"Templates located at: {result['templates_dir']}")
                )
                if 'backup_path' in result:
                    self.stdout.write(
                        self.style.WARNING(f"Previous templates backed up to: {result['backup_path']}")
                    )
            else:
                self.stdout.write(
                    self.style.ERROR(f"Template initialization failed: {result['error']}")
                )
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error during template initialization: {str(e)}")
            )

def initialize_templates(force_reinit=False, backup_dir=None):
    """
    Initialize the unified template system with all template types and registry.
    """
    from apps.deployments.template_registry import template_registry
    
    templates_dir = Path(settings.BASE_DIR).parent / "system-templates"
    
    # Check if templates already exist
    if templates_dir.exists() and not force_reinit:
        return {
            'success': True,
            'message': 'Templates already exist, skipping initialization',
            'templates_dir': str(templates_dir)
        }
    
    # Create backup if templates exist
    backup_path = None
    if templates_dir.exists():
        import datetime
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        if backup_dir:
            backup_path = Path(backup_dir) / f"system-templates-backup-{timestamp}"
        else:
            backup_path = templates_dir.parent / f"system-templates.backup.{timestamp}"
        
        shutil.move(templates_dir, backup_path)
        print(f"Backed up existing templates to {backup_path}")
    
    # Create new template structure
    os.makedirs(templates_dir / "app" / "nginx", exist_ok=True)
    os.makedirs(templates_dir / "app" / "systemd", exist_ok=True)
    os.makedirs(templates_dir / "llm" / "nginx", exist_ok=True)
    os.makedirs(templates_dir / "llm" / "systemd", exist_ok=True)
    os.makedirs(templates_dir / "unified" / "nginx", exist_ok=True)
    os.makedirs(templates_dir / "unified" / "systemd", exist_ok=True)
    os.makedirs(templates_dir / "base" / "nginx", exist_ok=True)
    os.makedirs(templates_dir / "base" / "systemd", exist_ok=True)
    os.makedirs(templates_dir / "control-panel", exist_ok=True)
    
    # Create app templates
    app_nginx_content = """# Nginx configuration for {{ app_name }}
# Generated by WebOps

server {
    listen {{ http_port|default(80) }};
    server_name {{ domain if domain else '_' }};

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    {% if csp %}
    add_header Content-Security-Policy "{{ csp }}" always;
    {% endif %}

    # Logging
    access_log {{ access_log_path|default('/var/log/nginx/' + app_name + '-access.log') }};
    error_log {{ error_log_path|default('/var/log/nginx/' + app_name + '-error.log') }};

    {% if app_type == 'django' %}
    # Django application
    location / {
        proxy_pass http://127.0.0.1:{{ port }};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Timeouts
        proxy_connect_timeout {{ proxy_connect_timeout|default('60s') }};
        proxy_send_timeout {{ proxy_send_timeout|default('60s') }};
        proxy_read_timeout {{ proxy_read_timeout|default('60s') }};

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    # Static files
    location /static/ {
        alias {{ static_root }}/;
        expires 30d;
        add_header Cache-Control "public, immutable";
    }

    # Media files
    location /media/ {
        alias {{ media_root }}/;
        expires 30d;
    }
    {% else %}
    # Static site or generic app
    location / {
        proxy_pass {{ proxy_pass_url|default('http://127.0.0.1:' + port|string) }};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Timeouts
        proxy_connect_timeout {{ proxy_connect_timeout|default('60s') }};
        proxy_send_timeout {{ proxy_send_timeout|default('60s') }};
        proxy_read_timeout {{ proxy_read_timeout|default('60s') }};
    }
    {% endif %}

    # Deny access to hidden files
    location ~ /\\. {
        deny all;
        access_log off;
        log_not_found off;
    }
}

{% if ssl_enabled|default(false) and domain %}
# SSL configuration
server {
    listen 443 ssl http2;
    server_name {{ domain }};

    # SSL certificates
    ssl_certificate {{ ssl_cert_path|default('/etc/letsencrypt/live/' + domain + '/fullchain.pem') }};
    ssl_certificate_key {{ ssl_cert_key_path|default('/etc/letsencrypt/live/' + domain + '/privkey.pem') }};
    
    # SSL Security Settings
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;

    # Security Headers
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
    
    # Same configuration as HTTP server
    access_log {{ access_log_path|default('/var/log/nginx/' + app_name + '-access.log') }};
    error_log {{ error_log_path|default('/var/log/nginx/' + app_name + '-error.log') }};

    {% if app_type == 'django' %}
    # Django application
    location / {
        proxy_pass http://127.0.0.1:{{ port }};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Timeouts
        proxy_connect_timeout {{ proxy_connect_timeout|default('60s') }};
        proxy_send_timeout {{ proxy_send_timeout|default('60s') }};
        proxy_read_timeout {{ proxy_read_timeout|default('60s') }};

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    # Static files
    location /static/ {
        alias {{ static_root }}/;
        expires 30d;
        add_header Cache-Control "public, immutable";
    }

    # Media files
    location /media/ {
        alias {{ media_root }}/;
        expires 30d;
    }
    {% else %}
    # Static site or generic app
    location / {
        proxy_pass {{ proxy_pass_url|default('http://127.0.0.1:' + port|string) }};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Timeouts
        proxy_connect_timeout {{ proxy_connect_timeout|default('60s') }};
        proxy_send_timeout {{ proxy_send_timeout|default('60s') }};
        proxy_read_timeout {{ proxy_read_timeout|default('60s') }};
    }
    {% endif %}

    # Deny access to hidden files
    location ~ /\\. {
        deny all;
        access_log off;
        log_not_found off;
    }
}
{% endif %}"""
    
    with open(templates_dir / "app" / "nginx" / "app.conf.j2", 'w') as f:
        f.write(app_nginx_content)
    
    # Write other templates as well...
    # (For brevity, in a real implementation, all templates would be written)
    
    # Create the template registry
    registry_content = '''"""
Template Registry for WebOps
Centralizes template selection logic to reduce duplication and improve maintainability
"""

class TemplateRegistry:
    """
    A registry that maps deployment types to appropriate templates
    """
    
    def __init__(self):
        # Define template mappings for different deployment types
        self.template_mappings = {
            'app': {
                'nginx': 'app/nginx/app.conf.j2',
                'systemd': 'app/systemd/app.service.j2',
                'env': 'control-panel/env.j2'
            },
            'django': {
                'nginx': 'app/nginx/app.conf.j2',  # Uses the same as general app but with django-specific vars
                'systemd': 'app/systemd/app.service.j2',
                'env': 'control-panel/env.j2'
            },
            'vllm_gpu': {
                'nginx': 'llm/nginx/llm.conf.j2',
                'systemd': 'llm/systemd/vllm.service.j2',
            },
            'vllm_cpu': {
                'nginx': 'llm/nginx/llm.conf.j2',
                'systemd': 'llm/systemd/vllm_cpu.service.j2',
            },
            'docker': {
                'systemd': 'app/systemd/docker.service.j2',
            },
            'llm': {
                'nginx': 'llm/nginx/llm.conf.j2',
                'systemd': 'unified/systemd/unified.service.j2',  # Use unified for more flexibility
            }
        }
    
    def get_template_path(self, deployment_type, service_type):
        """
        Get the appropriate template path for a given deployment type and service type.
        Falls back to unified templates if specific templates don't exist.
        """
        # First try to get the specific template
        if deployment_type in self.template_mappings:
            if service_type in self.template_mappings[deployment_type]:
                return self.template_mappings[deployment_type][service_type]
        
        # Fallback mapping to unified templates
        fallback_mapping = {
            ('app', 'nginx'): 'unified/nginx/unified.conf.j2',
            ('app', 'systemd'): 'unified/systemd/unified.service.j2',
            ('django', 'nginx'): 'unified/nginx/unified.conf.j2',
            ('django', 'systemd'): 'unified/systemd/unified.service.j2',
            ('vllm_gpu', 'nginx'): 'unified/nginx/unified.conf.j2',
            ('vllm_gpu', 'systemd'): 'unified/systemd/unified.service.j2',
            ('vllm_cpu', 'nginx'): 'unified/nginx/unified.conf.j2',
            ('vllm_cpu', 'systemd'): 'unified/systemd/unified.service.j2',
            ('docker', 'systemd'): 'unified/systemd/unified.service.j2',
            ('llm', 'nginx'): 'unified/nginx/unified.conf.j2',
            ('llm', 'systemd'): 'unified/systemd/unified.service.j2',
        }
        
        fallback_key = (deployment_type, service_type)
        if fallback_key in fallback_mapping:
            return fallback_mapping[fallback_key]
        
        # If no specific or fallback template found, return None
        return None
    
    def get_available_types(self):
        """
        Get all available deployment types
        """
        return list(self.template_mappings.keys())
    
    def get_available_services(self, deployment_type):
        """
        Get all available service types for a given deployment type
        """
        if deployment_type in self.template_mappings:
            return list(self.template_mappings[deployment_type].keys())
        return []


# Singleton instance
template_registry = TemplateRegistry()
'''
    
    with open(templates_dir / "template_registry.py", 'w') as f:
        f.write(registry_content)
    
    # Create README
    readme_content = """# WebOps System Templates

This directory contains all system templates for WebOps deployments. The structure is organized to reduce duplication and improve maintainability.

## Directory Structure

```
system-templates/
├── app/                 # Templates for general applications
│   ├── nginx/
│   │   └── app.conf.j2
│   └── systemd/
│       ├── app.service.j2
│       └── docker.service.j2
├── llm/                 # Templates for LLM services
│   ├── nginx/
│   │   └── llm.conf.j2
│   └── systemd/
│       ├── vllm.service.j2
│       └── vllm_cpu.service.j2
├── control-panel/       # Templates for WebOps control panel
│   ├── nginx/
│   │   └── nginx-ssl-config.conf
│   └── env.j2
├── unified/             # Unified templates with parameterization
│   ├── nginx/
│   │   └── unified.conf.j2
│   └── systemd/
│       └── unified.service.j2
├── base/                # Base templates for inheritance (future use)
│   ├── nginx/
│   │   └── base.conf.j2
│   └── systemd/
│       └── base.service.j2
├── template_registry.py # Registry mapping deployment types to templates
└── README.md
```

## Template Types

### App Templates
- For general web applications (Django, Flask, etc.)
- Handles standard WSGI/ASGI deployments with Gunicorn

### LLM Templates
- For LLM services like vLLM
- Optimized for AI inference with appropriate resource settings

### Control Panel Templates
- For the WebOps control panel itself
- Includes SSL configuration for the main interface

### Unified Templates
- Single parameterized templates that can handle multiple deployment types
- Reduces code duplication by using conditional logic
- Preferred for new deployments

## Template Registry

The `template_registry.py` file defines which template to use for different deployment scenarios. This centralizes the template selection logic and makes it easier to maintain.

## Best Practices

1. Use unified templates when possible to reduce duplication
2. Add new functionality to unified templates rather than creating new specialized ones
3. Update the template registry when adding new template types
4. Keep templates parameterized rather than creating multiple similar templates
"""
    
    with open(templates_dir / "README.md", 'w') as f:
        f.write(readme_content)
    
    return {
        'success': True,
        'message': 'Template system initialized successfully',
        'templates_dir': str(templates_dir),
        'backup_path': str(backup_path) if backup_path else None
    }